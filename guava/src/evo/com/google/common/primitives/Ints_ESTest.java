/*
* This file was automatically generated by EvoSuite
* Wed Feb 26 18:05:45 GMT 2020
*/

package com.google.common.primitives;

import com.google.common.base.Converter;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Comparator;
import java.util.List;

import static org.evosuite.runtime.EvoAssertions.*;
import static org.junit.Assert.*;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true)
public class Ints_ESTest extends Ints_ESTest_scaffolding {
    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     reverse() chamada com argumentos ilegais lança uma IndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test00() throws Throwable {
        int int0 = Ints.saturatedCast(4611686018427387904L);
        assertEquals(Integer.MAX_VALUE, int0);

        int[] intArray0 = new int[2];
        int int1 = (-161);
        intArray0[0] = (-161);
        intArray0[1] = Integer.MAX_VALUE;
        // Undeclared exception!
        try {
            Ints.reverse(intArray0, (-161), (-2290));
            fail("Expecting exception: IndexOutOfBoundsException");

        } catch (IndexOutOfBoundsException e) {
            //
            // start index (-161) must not be negative
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test01() throws Throwable {
        Integer integer0 = Ints.tryParse("0q]E\")");
        assertNull(integer0);

        int[] intArray0 = new int[1];
        String string0 = Ints.join("0q]E\")", intArray0);
        assertEquals("0", string0);
        assertNotNull(string0);
        assertEquals(1, intArray0.length);
        assertArrayEquals(new int[]{0}, intArray0);

        int int0 = Ints.max(intArray0);
        assertEquals(0, int0);
        assertEquals(1, intArray0.length);
        assertArrayEquals(new int[]{0}, intArray0);

        int int1 = Ints.max(intArray0);
        assertEquals(0, int1);
        assertEquals(1, intArray0.length);
        assertTrue(int1 == int0);
        assertArrayEquals(new int[]{0}, intArray0);

        int int2 = Ints.min(intArray0);
        assertEquals(0, int2);
        assertEquals(1, intArray0.length);
        assertTrue(int2 == int0);
        assertTrue(int2 == int1);
        assertArrayEquals(new int[]{0}, intArray0);

        boolean boolean0 = Ints.contains(intArray0, 0);
        assertTrue(boolean0);
        assertEquals(1, intArray0.length);
        assertArrayEquals(new int[]{0}, intArray0);

        int[] intArray1 = new int[9];
        assertFalse(intArray1.equals((Object) intArray0));

        intArray1[0] = 0;
        intArray1[1] = 0;
        intArray1[2] = 0;
        intArray1[3] = 0;
        intArray1[4] = 0;
        intArray1[5] = 0;
        intArray1[7] = 0;
        intArray1[8] = 311;
        List<Integer> list0 = Ints.asList(intArray1);
        assertNotSame(intArray1, intArray0);
        assertNotNull(list0);
        assertTrue(list0.contains(0));
        assertEquals(9, list0.size());
        assertFalse(list0.isEmpty());
        assertEquals(9, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray0));
        assertArrayEquals(new int[]{0, 0, 0, 0, 0, 0, 0, 0, 311}, intArray1);

        int int3 = Ints.min(intArray0);
        assertEquals(0, int3);
        assertNotSame(intArray0, intArray1);
        assertEquals(1, intArray0.length);
        assertTrue(int3 == int1);
        assertTrue(int3 == int0);
        assertTrue(int3 == int2);
        assertFalse(intArray0.equals((Object) intArray1));
        assertArrayEquals(new int[]{0}, intArray0);

        boolean boolean1 = Ints.contains(intArray1, 0);
        assertTrue(boolean1);
        assertNotSame(intArray1, intArray0);
        assertEquals(9, intArray1.length);
        assertTrue(boolean1 == boolean0);
        assertFalse(intArray1.equals((Object) intArray0));
        assertArrayEquals(new int[]{0, 0, 0, 0, 0, 0, 0, 0, 311}, intArray1);

        Converter<String, Integer> converter0 = Ints.stringConverter();
        assertNotNull(converter0);

        Integer integer1 = Ints.tryParse("0");
        assertEquals(0, (int) integer1);
        assertNotNull(integer1);
        assertTrue(integer1.equals((Object) int0));
        assertTrue(integer1.equals((Object) int3));
        assertTrue(integer1.equals((Object) int1));
        assertTrue(integer1.equals((Object) int2));
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     checkedCast() chamada com argumentos ilegais lança uma IllegalArgumentException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test02() throws Throwable {
        // Undeclared exception!
        try {
            Ints.checkedCast(9223372036854775794L);
            fail("Expecting exception: IllegalArgumentException");

        } catch (IllegalArgumentException e) {
            //
            // Out of range: 9223372036854775794
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test03() throws Throwable {
        Integer integer0 = Ints.tryParse("0q]E\")");
        assertNull(integer0);

        byte[] byteArray0 = Ints.toByteArray(6);
        assertNotNull(byteArray0);
        assertEquals(4, byteArray0.length);
        assertArrayEquals(new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 6}, byteArray0);

        int[] intArray0 = new int[18];
        intArray0[0] = 6;
        String string0 = Ints.join("", intArray0);
        assertEquals("600000000000000000", string0);
        assertNotNull(string0);
        assertEquals(18, intArray0.length);

        int int0 = Ints.max(intArray0);
        assertEquals(6, int0);
        assertEquals(18, intArray0.length);

        int int1 = Ints.max(intArray0);
        assertEquals(6, int1);
        assertEquals(18, intArray0.length);
        assertTrue(int1 == int0);

        int int2 = Ints.min(intArray0);
        assertEquals(0, int2);
        assertEquals(18, intArray0.length);
        assertFalse(int2 == int0);
        assertFalse(int2 == int1);

        boolean boolean0 = Ints.contains(intArray0, 0);
        assertTrue(boolean0);
        assertEquals(18, intArray0.length);

        int[] intArray1 = Ints.ensureCapacity(intArray0, 6, 6);
        assertSame(intArray0, intArray1);
        assertSame(intArray1, intArray0);
        assertNotNull(intArray1);
        assertEquals(18, intArray0.length);
        assertEquals(18, intArray1.length);

        int[] intArray2 = new int[9];
        assertFalse(intArray2.equals((Object) intArray0));
        assertFalse(intArray2.equals((Object) intArray1));

        intArray2[0] = 0;
        intArray2[1] = 0;
        intArray2[2] = 6;
        intArray2[3] = 6;
        intArray2[4] = 0;
        intArray2[5] = 6;
        intArray2[6] = 6;
        intArray2[7] = 6;
        intArray0[14] = 311;
        int int3 = Ints.MAX_POWER_OF_TWO;
        assertEquals(1073741824, int3);
        assertFalse(int3 == int0);
        assertFalse(int3 == int1);
        assertFalse(int3 == int2);

        List<Integer> list0 = Ints.asList(intArray2);
        assertNotSame(intArray2, intArray0);
        assertNotSame(intArray2, intArray1);
        assertNotNull(list0);
        assertTrue(list0.contains(6));
        assertFalse(list0.contains(int3));
        assertEquals(9, list0.size());
        assertFalse(list0.isEmpty());
        assertEquals(9, intArray2.length);
        assertFalse(intArray2.equals((Object) intArray0));
        assertFalse(intArray2.equals((Object) intArray1));
        assertArrayEquals(new int[]{0, 0, 6, 6, 0, 6, 6, 6, 0}, intArray2);

        int int4 = Ints.min(intArray0);
        assertEquals(0, int4);
        assertSame(intArray0, intArray1);
        assertNotSame(intArray0, intArray2);
        assertEquals(18, intArray0.length);
        assertFalse(intArray0.equals((Object) intArray2));
        assertTrue(int4 == int2);
        assertFalse(int4 == int0);
        assertFalse(int4 == int1);
        assertFalse(int4 == int3);

        boolean boolean1 = Ints.contains(intArray2, 6);
        assertTrue(boolean1);
        assertNotSame(intArray2, intArray0);
        assertNotSame(intArray2, intArray1);
        assertEquals(9, intArray2.length);
        assertTrue(boolean1 == boolean0);
        assertFalse(intArray2.equals((Object) intArray0));
        assertFalse(intArray2.equals((Object) intArray1));
        assertArrayEquals(new int[]{0, 0, 6, 6, 0, 6, 6, 6, 0}, intArray2);

        Converter<String, Integer> converter0 = Ints.stringConverter();
        assertNotNull(converter0);

        Integer integer1 = Ints.tryParse("600000000000000000");
        assertNull(integer1);

        int int5 = Ints.indexOf(intArray1, intArray2);
        assertEquals((-1), int5);
        assertSame(intArray0, intArray1);
        assertNotSame(intArray0, intArray2);
        assertNotSame(intArray1, intArray2);
        assertSame(intArray1, intArray0);
        assertNotSame(intArray2, intArray0);
        assertNotSame(intArray2, intArray1);
        assertEquals(18, intArray0.length);
        assertEquals(18, intArray1.length);
        assertEquals(9, intArray2.length);
        assertFalse(intArray0.equals((Object) intArray2));
        assertFalse(intArray1.equals((Object) intArray2));
        assertFalse(int5 == int2);
        assertFalse(int5 == int4);
        assertFalse(int5 == int3);
        assertFalse(int5 == int0);
        assertFalse(int5 == int1);
        assertFalse(intArray2.equals((Object) intArray0));
        assertFalse(intArray2.equals((Object) intArray1));
        assertArrayEquals(new int[]{0, 0, 6, 6, 0, 6, 6, 6, 0}, intArray2);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     reverse() chamada com argumentos ilegais lança uma IndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test04() throws Throwable {
        int int0 = Ints.saturatedCast((-2147483648L));
        assertEquals(Integer.MIN_VALUE, int0);

        int[] intArray0 = new int[1];
        intArray0[0] = Integer.MIN_VALUE;
        int int1 = Ints.min(intArray0);
        assertEquals(Integer.MIN_VALUE, int1);
        assertEquals(1, intArray0.length);
        assertTrue(int1 == int0);
        assertArrayEquals(new int[]{Integer.MIN_VALUE}, intArray0);

        // Undeclared exception!
        try {
            Ints.reverse(intArray0, Integer.MIN_VALUE, Integer.MIN_VALUE);
            fail("Expecting exception: IndexOutOfBoundsException");

        } catch (IndexOutOfBoundsException e) {
            //
            // start index (-2147483648) must not be negative
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     reverse() chamada com argumentos ilegais lança uma IndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test05() throws Throwable {
        int int0 = 0;
        int int1 = Ints.hashCode(0);
        assertTrue(int1 == int0);

        int int2 = Ints.MAX_POWER_OF_TWO;
        assertEquals(1073741824, int2);
        assertFalse(int2 == int0);

        int[] intArray0 = new int[2];
        intArray0[0] = 1073741824;
        // Undeclared exception!
        try {
            Ints.contains((int[]) null, 1073741824);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.primitives.Ints", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados. Além de verificar se ensureCapacity() chamada
    *     com argumentos ilegais lança uma NegativeArraySizeException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test06() throws Throwable {
        int int0 = Ints.checkedCast(0L);
        assertEquals(0, int0);

        int[] intArray0 = new int[1];
        intArray0[0] = 0;
        int int1 = Ints.max(intArray0);
        assertEquals(0, int1);
        assertEquals(1, intArray0.length);
        assertTrue(int1 == int0);
        assertArrayEquals(new int[]{0}, intArray0);

        Integer integer0 = Ints.tryParse("com.google.common.base.Strings", 31);
        assertNull(integer0);

        Integer integer1 = Ints.tryParse("");
        assertNull(integer1);

        int int2 = Ints.indexOf(intArray0, intArray0);
        assertEquals(0, int2);
        assertEquals(1, intArray0.length);
        assertTrue(int2 == int1);
        assertTrue(int2 == int0);
        assertArrayEquals(new int[]{0}, intArray0);

        int int3 = Ints.saturatedCast(0);
        assertEquals(0, int3);
        assertTrue(int3 == int2);
        assertTrue(int3 == int0);
        assertTrue(int3 == int1);

        boolean boolean0 = Ints.contains(intArray0, 1759);
        assertFalse(boolean0);
        assertEquals(1, intArray0.length);
        assertArrayEquals(new int[]{0}, intArray0);

        int int4 = Ints.fromBytes((byte) 91, (byte) 24, (byte) 91, (byte) 24);
        assertEquals(1528322840, int4);
        assertFalse(int4 == int2);
        assertFalse(int4 == int3);
        assertFalse(int4 == int0);
        assertFalse(int4 == int1);

        int int5 = Ints.min(intArray0);
        assertEquals(0, int5);
        assertEquals(1, intArray0.length);
        assertTrue(int5 == int2);
        assertTrue(int5 == int0);
        assertTrue(int5 == int1);
        assertFalse(int5 == int4);
        assertTrue(int5 == int3);
        assertArrayEquals(new int[]{0}, intArray0);

        byte[] byteArray0 = Ints.toByteArray(0);
        assertNotNull(byteArray0);
        assertEquals(4, byteArray0.length);
        assertArrayEquals(new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 0}, byteArray0);

        int int6 = Ints.saturatedCast(1528322840);
        assertEquals(1528322840, int6);
        assertTrue(int6 == int4);
        assertFalse(int6 == int1);
        assertFalse(int6 == int3);
        assertFalse(int6 == int0);
        assertFalse(int6 == int5);
        assertFalse(int6 == int2);

        Integer integer2 = Ints.tryParse("com.google.common.base.Strings");
        assertNull(integer2);

        // Undeclared exception!
        try {
            Ints.ensureCapacity(intArray0, 91, 2147483605);
            fail("Expecting exception: NegativeArraySizeException");

        } catch (NegativeArraySizeException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("java.util.Arrays", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test07() throws Throwable {
        int int0 = Ints.MAX_POWER_OF_TWO;
        assertEquals(1073741824, int0);

        int[] intArray0 = new int[5];
        intArray0[0] = 1073741824;
        intArray0[1] = 1073741824;
        intArray0[2] = 1073741824;
        intArray0[4] = 0;
        List<Integer> list0 = Ints.asList(intArray0);
        assertNotNull(list0);
        assertTrue(list0.contains(1073741824));
        assertFalse(list0.isEmpty());
        assertEquals(5, list0.size());
        assertEquals(5, intArray0.length);
        assertArrayEquals(new int[]{1073741824, 1073741824, 1073741824, 0, 0}, intArray0);

        int[] intArray1 = Ints.toArray(list0);
        assertNotSame(intArray0, intArray1);
        assertNotSame(intArray1, intArray0);
        assertNotNull(intArray1);
        assertTrue(list0.contains(1073741824));
        assertFalse(list0.isEmpty());
        assertEquals(5, list0.size());
        assertEquals(5, intArray0.length);
        assertEquals(5, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray0));
        assertArrayEquals(new int[]{1073741824, 1073741824, 1073741824, 0, 0}, intArray0);
        assertArrayEquals(new int[]{1073741824, 1073741824, 1073741824, 0, 0}, intArray1);

        Integer integer0 = new Integer(0);
        assertEquals(0, (int) integer0);
        assertNotNull(integer0);
        assertFalse(integer0.equals((Object) int0));

        int[] intArray2 = new int[1];
        assertFalse(intArray2.equals((Object) intArray1));
        assertFalse(intArray2.equals((Object) intArray0));

        int int1 = Ints.indexOf(intArray1, intArray2);
        assertEquals(3, int1);
        assertNotSame(intArray0, intArray2);
        assertNotSame(intArray0, intArray1);
        assertNotSame(intArray1, intArray2);
        assertNotSame(intArray1, intArray0);
        assertNotSame(intArray2, intArray1);
        assertNotSame(intArray2, intArray0);
        assertTrue(list0.contains(0));
        assertFalse(list0.contains(int1));
        assertFalse(list0.isEmpty());
        assertEquals(5, list0.size());
        assertEquals(5, intArray0.length);
        assertEquals(5, intArray1.length);
        assertEquals(1, intArray2.length);
        assertFalse(intArray0.equals((Object) intArray2));
        assertFalse(intArray0.equals((Object) intArray1));
        assertFalse(intArray1.equals((Object) intArray2));
        assertFalse(intArray1.equals((Object) intArray0));
        assertFalse(intArray2.equals((Object) intArray1));
        assertFalse(intArray2.equals((Object) intArray0));
        assertFalse(int1 == int0);
        assertArrayEquals(new int[]{1073741824, 1073741824, 1073741824, 0, 0}, intArray0);
        assertArrayEquals(new int[]{1073741824, 1073741824, 1073741824, 0, 0}, intArray1);
        assertArrayEquals(new int[]{0}, intArray2);

        int int2 = Ints.fromBytes((byte) (-63), (byte) (-63), (byte) (-63), (byte) 3);
        assertEquals((-1044266749), int2);
        assertFalse(int2 == int0);
        assertFalse(int2 == int1);

        int[][] intArray3 = new int[9][1];
        intArray3[0] = intArray1;
        intArray3[1] = intArray0;
        intArray3[2] = intArray0;
        intArray3[3] = intArray1;
        intArray3[4] = intArray1;
        intArray3[5] = intArray0;
        intArray3[6] = intArray0;
        int[] intArray4 = new int[3];
        assertFalse(intArray4.equals((Object) intArray1));
        assertFalse(intArray4.equals((Object) intArray0));
        assertFalse(intArray4.equals((Object) intArray2));

        intArray4[0] = 27;
        intArray4[1] = 0;
        intArray4[2] = 485;
        intArray3[7] = intArray4;
        intArray3[8] = intArray2;
        int[] intArray5 = Ints.concat(intArray3);
        assertNotSame(intArray5, intArray1);
        assertNotSame(intArray5, intArray2);
        assertNotSame(intArray5, intArray0);
        assertNotSame(intArray5, intArray4);
        assertNotNull(intArray5);
        assertEquals(39, intArray5.length);
        assertEquals(9, intArray3.length);
        assertFalse(intArray5.equals((Object) intArray1));
        assertFalse(intArray5.equals((Object) intArray2));
        assertFalse(intArray5.equals((Object) intArray0));
        assertFalse(intArray5.equals((Object) intArray4));

        Converter<String, Integer> converter0 = Ints.stringConverter();
        assertNotNull(converter0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     reverse() chamada com argumentos ilegais lança uma IndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test08() throws Throwable {
        Integer integer0 = Ints.tryParse("F", 16);
        assertEquals(15, (int) integer0);
        assertNotNull(integer0);

        int[] intArray0 = new int[0];
        int int0 = Ints.MAX_POWER_OF_TWO;
        assertEquals(1073741824, int0);

        // Undeclared exception!
        try {
            Ints.reverse(intArray0, 16, (-1877));
            fail("Expecting exception: IndexOutOfBoundsException");

        } catch (IndexOutOfBoundsException e) {
            //
            // start index (16) must not be greater than size (0)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     reverse() chamada com argumentos ilegais lança uma IndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test09() throws Throwable {
        Ints.hashCode(0);
        int int0 = Ints.checkedCast(0);
        assertEquals(0, int0);

        int[] intArray0 = new int[2];
        intArray0[0] = 0;
        boolean boolean0 = Ints.contains(intArray0, 0);
        assertTrue(boolean0);
        assertEquals(2, intArray0.length);
        assertArrayEquals(new int[]{0, 0}, intArray0);

        int int1 = Ints.hashCode(0);
        assertTrue(int1 == int0);

        byte[] byteArray0 = new byte[6];
        int int2 = Ints.fromByteArray(byteArray0);
        assertEquals(0, int2);
        assertEquals(6, byteArray0.length);
        assertTrue(int2 == int0);
        assertArrayEquals(new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0}, byteArray0);

        // Undeclared exception!
        try {
            Ints.reverse(intArray0, (-2235), (-2235));
            fail("Expecting exception: IndexOutOfBoundsException");

        } catch (IndexOutOfBoundsException e) {
            //
            // start index (-2235) must not be negative
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test10() throws Throwable {
        byte[] byteArray0 = Ints.toByteArray(31);
        assertNotNull(byteArray0);
        assertEquals(4, byteArray0.length);
        assertArrayEquals(new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 31}, byteArray0);

        Integer integer0 = Ints.tryParse("", 31);
        assertNull(integer0);

        int int0 = Ints.checkedCast(31);
        assertEquals(31, int0);

        int int1 = Ints.fromByteArray(byteArray0);
        assertEquals(31, int1);
        assertEquals(4, byteArray0.length);
        assertTrue(int1 == int0);
        assertArrayEquals(new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 31}, byteArray0);

        int[] intArray0 = new int[2];
        intArray0[0] = 31;
        intArray0[1] = 31;
        int int2 = Ints.max(intArray0);
        assertEquals(31, int2);
        assertEquals(2, intArray0.length);
        assertTrue(int2 == int0);
        assertTrue(int2 == int1);
        assertArrayEquals(new int[]{31, 31}, intArray0);

        int int3 = Ints.hashCode(31);
        assertTrue(int3 == int1);
        assertTrue(int3 == int2);
        assertTrue(int3 == int0);

        int int4 = Ints.max(intArray0);
        assertEquals(31, int4);
        assertEquals(2, intArray0.length);
        assertTrue(int4 == int0);
        assertTrue(int4 == int2);
        assertTrue(int4 == int1);
        assertArrayEquals(new int[]{31, 31}, intArray0);

        int int5 = Ints.max(intArray0);
        assertEquals(31, int5);
        assertEquals(2, intArray0.length);
        assertTrue(int5 == int1);
        assertTrue(int5 == int4);
        assertTrue(int5 == int2);
        assertTrue(int5 == int0);
        assertArrayEquals(new int[]{31, 31}, intArray0);

        int int6 = Ints.saturatedCast(887L);
        assertEquals(887, int6);
        assertFalse(int6 == int4);
        assertFalse(int6 == int0);
        assertFalse(int6 == int5);
        assertFalse(int6 == int1);
        assertFalse(int6 == int2);

        List<Integer> list0 = Ints.asList(intArray0);
        assertNotNull(list0);
        assertTrue(list0.contains(31));
        assertFalse(list0.contains(int6));
        assertFalse(list0.isEmpty());
        assertEquals(2, list0.size());
        assertEquals(2, intArray0.length);
        assertArrayEquals(new int[]{31, 31}, intArray0);

        int int7 = Ints.saturatedCast(2147483647L);
        assertEquals(Integer.MAX_VALUE, int7);
        assertFalse(int7 == int5);
        assertFalse(int7 == int2);
        assertFalse(int7 == int0);
        assertFalse(int7 == int6);
        assertFalse(int7 == int4);
        assertFalse(int7 == int1);
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     tryParse() chamada com argumentos ilegais lança uma IllegalArgumentException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test11() throws Throwable {
        int[] intArray0 = new int[2];
        int int0 = (-3000);
        intArray0[0] = (-3000);
        int int1 = (-2773);
        intArray0[1] = (-2773);
        int int2 = Ints.max(intArray0);
        assertEquals((-2773), int2);
        assertEquals(2, intArray0.length);
        assertFalse(int2 == int0);
        assertTrue(int2 == int1);
        assertArrayEquals(new int[]{(-3000), (-2773)}, intArray0);

        String string0 = "IPDewTA3";
        // Undeclared exception!
        try {
            Ints.tryParse("IPDewTA3", (-3000));
            fail("Expecting exception: IllegalArgumentException");

        } catch (IllegalArgumentException e) {
            //
            // radix must be between MIN_RADIX and MAX_RADIX but was -3000
            //
            verifyException("com.google.common.primitives.Longs", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados. Além de verificar se tryParse() chamada
    *     com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test12() throws Throwable {
        int[] intArray0 = new int[7];
        intArray0[0] = (-1749);
        intArray0[1] = 1;
        intArray0[2] = 903;
        intArray0[3] = 178;
        intArray0[4] = 8;
        intArray0[5] = (-3908);
        intArray0[6] = 91;
        int int0 = Ints.indexOf(intArray0, intArray0);
        assertEquals(0, int0);
        assertEquals(7, intArray0.length);
        assertArrayEquals(new int[]{(-1749), 1, 903, 178, 8, (-3908), 91}, intArray0);

        int int1 = Ints.compare(1, (-3908));
        assertEquals(1, int1);
        assertFalse(int1 == int0);

        int int2 = Ints.saturatedCast(91);
        assertEquals(91, int2);
        assertFalse(int2 == int0);
        assertFalse(int2 == int1);

        int int3 = Ints.min(intArray0);
        assertEquals((-3908), int3);
        assertEquals(7, intArray0.length);
        assertFalse(int3 == int1);
        assertFalse(int3 == int2);
        assertFalse(int3 == int0);
        assertArrayEquals(new int[]{(-1749), 1, 903, 178, 8, (-3908), 91}, intArray0);

        int[] intArray1 = Ints.ensureCapacity(intArray0, 1, 299);
        assertSame(intArray0, intArray1);
        assertSame(intArray1, intArray0);
        assertNotNull(intArray1);
        assertEquals(7, intArray0.length);
        assertEquals(7, intArray1.length);
        assertArrayEquals(new int[]{(-1749), 1, 903, 178, 8, (-3908), 91}, intArray0);
        assertArrayEquals(new int[]{(-1749), 1, 903, 178, 8, (-3908), 91}, intArray1);

        int int4 = Ints.min(intArray0);
        assertEquals((-3908), int4);
        assertSame(intArray0, intArray1);
        assertEquals(7, intArray0.length);
        assertFalse(int4 == int0);
        assertFalse(int4 == int2);
        assertTrue(int4 == int3);
        assertFalse(int4 == int1);
        assertArrayEquals(new int[]{(-1749), 1, 903, 178, 8, (-3908), 91}, intArray0);

        // Undeclared exception!
        try {
            Ints.tryParse((String) null, 476);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     reverse() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test13() throws Throwable {
        int int0 = Ints.constrainToRange(0, 0, 0);
        assertEquals(0, int0);

        int int1 = Ints.checkedCast(2131L);
        assertEquals(2131, int1);
        assertFalse(int1 == int0);

        int[] intArray0 = null;
        int int2 = (-462);
        // Undeclared exception!
        try {
            Ints.reverse((int[]) null, (-462), (-462));
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     ensureCapacity() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test14() throws Throwable {
        int int0 = 1073741824;
        int int1 = 2092;
        // Undeclared exception!
        try {
            Ints.ensureCapacity((int[]) null, 1073741824, 2092);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.primitives.Ints", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test15() throws Throwable {
        int int0 = Ints.checkedCast(0L);
        assertEquals(0, int0);

        int[] intArray0 = new int[6];
        intArray0[0] = 0;
        intArray0[1] = 0;
        intArray0[2] = (-4154);
        intArray0[3] = 0;
        intArray0[4] = 0;
        intArray0[5] = 0;
        String string0 = Ints.join("A>j0Uf&cy#=T%%&hz", intArray0);
        assertEquals("0A>j0Uf&cy#=T%%&hz0A>j0Uf&cy#=T%%&hz-4154A>j0Uf&cy#=T%%&hz0A>j0Uf&cy#=T%%&hz0A>j0Uf&cy#=T%%&hz0", string0);
        assertNotNull(string0);
        assertEquals(6, intArray0.length);
        assertArrayEquals(new int[]{0, 0, (-4154), 0, 0, 0}, intArray0);

        Ints.reverse(intArray0);
        assertEquals(6, intArray0.length);
        assertArrayEquals(new int[]{0, 0, 0, (-4154), 0, 0}, intArray0);

        List<Integer> list0 = Ints.asList(intArray0);
        assertNotNull(list0);
        assertTrue(list0.contains(int0));
        assertFalse(list0.isEmpty());
        assertEquals(6, list0.size());
        assertEquals(6, intArray0.length);
        assertArrayEquals(new int[]{0, 0, 0, (-4154), 0, 0}, intArray0);

        Converter<String, Integer> converter0 = Ints.stringConverter();
        assertNotNull(converter0);

        int int1 = Ints.compare(0, 0);
        assertEquals(0, int1);
        assertTrue(int1 == int0);

        int int2 = Ints.max(intArray0);
        assertEquals(0, int2);
        assertEquals(6, intArray0.length);
        assertTrue(int2 == int0);
        assertTrue(int2 == int1);
        assertArrayEquals(new int[]{0, 0, 0, (-4154), 0, 0}, intArray0);

        int int3 = Ints.fromBytes((byte) 8, (byte) 2, (byte) 0, (byte) 77);
        assertEquals(134348877, int3);
        assertFalse(int3 == int1);
        assertFalse(int3 == int2);
        assertFalse(int3 == int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test16() throws Throwable {
        int int0 = Ints.compare(0, 0);
        assertEquals(0, int0);

        Converter<String, Integer> converter0 = Ints.stringConverter();
        assertNotNull(converter0);

        int[] intArray0 = new int[4];
        intArray0[0] = 0;
        intArray0[1] = 0;
        intArray0[2] = 0;
        intArray0[3] = 0;
        int[] intArray1 = Ints.ensureCapacity(intArray0, 0, 0);
        assertSame(intArray0, intArray1);
        assertSame(intArray1, intArray0);
        assertNotNull(intArray1);
        assertEquals(4, intArray0.length);
        assertEquals(4, intArray1.length);
        assertArrayEquals(new int[]{0, 0, 0, 0}, intArray0);
        assertArrayEquals(new int[]{0, 0, 0, 0}, intArray1);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados. Além de verificar se fromByteArray() chamada
    *     com argumentos ilegais lança uma IllegalArgumentException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test17() throws Throwable {
        int int0 = Ints.saturatedCast(0L);
        assertEquals(0, int0);

        int[] intArray0 = new int[4];
        intArray0[0] = 0;
        intArray0[1] = 0;
        intArray0[2] = 0;
        intArray0[3] = 0;
        int int1 = Ints.indexOf(intArray0, intArray0);
        assertEquals(0, int1);
        assertEquals(4, intArray0.length);
        assertTrue(int1 == int0);
        assertArrayEquals(new int[]{0, 0, 0, 0}, intArray0);

        int int2 = Ints.indexOf(intArray0, 1874);
        assertEquals((-1), int2);
        assertEquals(4, intArray0.length);
        assertFalse(int2 == int0);
        assertFalse(int2 == int1);
        assertArrayEquals(new int[]{0, 0, 0, 0}, intArray0);

        int int3 = Ints.fromBytes((byte) 0, (byte) 0, (byte) 0, (byte) 0);
        assertEquals(0, int3);
        assertTrue(int3 == int0);
        assertTrue(int3 == int1);
        assertFalse(int3 == int2);

        Ints.sortDescending(intArray0);
        assertEquals(4, intArray0.length);
        assertArrayEquals(new int[]{0, 0, 0, 0}, intArray0);

        byte[] byteArray0 = new byte[0];
        // Undeclared exception!
        try {
            Ints.fromByteArray(byteArray0);
            fail("Expecting exception: IllegalArgumentException");

        } catch (IllegalArgumentException e) {
            //
            // array too small: 0 < 4
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     indexOf() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test18() throws Throwable {
        Comparator<int[]> comparator0 = Ints.lexicographicalComparator();
        assertNotNull(comparator0);

        int[] intArray0 = null;
        // Undeclared exception!
        try {
            Ints.indexOf((int[]) null, 740);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.primitives.Ints", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     min() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test20() throws Throwable {
        int[] intArray0 = new int[1];
        intArray0[0] = (-2832);
        int int0 = (-4233);
        boolean boolean0 = Ints.contains(intArray0, (-4233));
        assertFalse(boolean0);
        assertEquals(1, intArray0.length);
        assertArrayEquals(new int[]{(-2832)}, intArray0);

        int[] intArray1 = null;
        // Undeclared exception!
        try {
            Ints.min((int[]) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.primitives.Ints", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados. Além de verificar se ensureCapacity() chamada
    *     com argumentos ilegais lança uma IllegalArgumentException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test22() throws Throwable {
        byte[] byteArray0 = new byte[5];
        byteArray0[0] = (byte) (-58);
        byteArray0[1] = (byte) 1;
        byteArray0[2] = (byte) 10;
        byte byte0 = (byte) 123;
        byteArray0[3] = (byte) 123;
        byte byte1 = (byte) (-82);
        byteArray0[4] = (byte) (-82);
        int int0 = Ints.fromByteArray(byteArray0);
        assertEquals((-973010309), int0);
        assertEquals(5, byteArray0.length);
        assertArrayEquals(new byte[]{(byte) (-58), (byte) 1, (byte) 10, (byte) 123, (byte) (-82)}, byteArray0);

        int[] intArray0 = new int[4];
        intArray0[0] = 2138;
        intArray0[1] = (int) (byte) (-82);
        intArray0[2] = (int) (byte) 123;
        intArray0[3] = (-1521);
        int int1 = 5;
        int int2 = Ints.indexOf(intArray0, 5);
        assertEquals((-1), int2);
        assertEquals(4, intArray0.length);
        assertFalse(int2 == int1);
        assertFalse(int2 == int0);
        assertArrayEquals(new int[]{2138, (-82), 123, (-1521)}, intArray0);

        int int3 = Ints.checkedCast(1L);
        assertEquals(1, int3);
        assertFalse(int3 == int1);
        assertFalse(int3 == int2);
        assertFalse(int3 == int0);

        int int4 = Ints.hashCode(388);
        assertFalse(int4 == int2);
        assertFalse(int4 == int3);
        assertFalse(int4 == int0);
        assertFalse(int4 == int1);

        // Undeclared exception!
        try {
            Ints.ensureCapacity(intArray0, (-1521), (byte) 10);
            fail("Expecting exception: IllegalArgumentException");

        } catch (IllegalArgumentException e) {
            //
            // Invalid minLength: -1521
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados. Além de verificar se fromByteArray() chamada
    *     com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test23() throws Throwable {
        Ints.hashCode(262);
        int[] intArray0 = new int[5];
        intArray0[0] = 262;
        intArray0[1] = 262;
        intArray0[2] = 262;
        intArray0[3] = 262;
        intArray0[4] = 262;
        List<Integer> list0 = Ints.asList(intArray0);
        assertNotNull(list0);
        assertTrue(list0.contains(262));
        assertEquals(5, list0.size());
        assertFalse(list0.isEmpty());
        assertEquals(5, intArray0.length);
        assertArrayEquals(new int[]{262, 262, 262, 262, 262}, intArray0);

        int int0 = Ints.max(intArray0);
        assertEquals(262, int0);
        assertEquals(5, intArray0.length);
        assertArrayEquals(new int[]{262, 262, 262, 262, 262}, intArray0);

        boolean boolean0 = Ints.contains(intArray0, 262);
        assertTrue(boolean0);
        assertEquals(5, intArray0.length);
        assertArrayEquals(new int[]{262, 262, 262, 262, 262}, intArray0);

        Integer integer0 = Ints.tryParse("Out of range: %s");
        assertNull(integer0);

        int int1 = Ints.max(intArray0);
        assertEquals(262, int1);
        assertEquals(5, intArray0.length);
        assertTrue(int1 == int0);
        assertArrayEquals(new int[]{262, 262, 262, 262, 262}, intArray0);

        Integer integer1 = Ints.tryParse("", 0);
        assertNull(integer1);

        int[] intArray1 = Ints.toArray(list0);
        assertNotSame(intArray0, intArray1);
        assertNotSame(intArray1, intArray0);
        assertNotNull(intArray1);
        assertFalse(list0.contains(0));
        assertTrue(list0.contains(262));
        assertEquals(5, list0.size());
        assertFalse(list0.isEmpty());
        assertEquals(5, intArray0.length);
        assertEquals(5, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray0));
        assertArrayEquals(new int[]{262, 262, 262, 262, 262}, intArray0);
        assertArrayEquals(new int[]{262, 262, 262, 262, 262}, intArray1);

        int[][] intArray2 = new int[0][3];
        int[] intArray3 = Ints.concat(intArray2);
        assertNotSame(intArray3, intArray0);
        assertNotSame(intArray3, intArray1);
        assertNotNull(intArray3);
        assertEquals(0, intArray2.length);
        assertEquals(0, intArray3.length);
        assertFalse(intArray3.equals((Object) intArray0));
        assertFalse(intArray3.equals((Object) intArray1));
        assertArrayEquals(new int[]{}, intArray3);

        int int2 = Ints.hashCode(262);
        assertTrue(int2 == int0);
        assertTrue(int2 == int1);

        // Undeclared exception!
        try {
            Ints.fromByteArray((byte[]) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.primitives.Ints", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     sortDescending() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test24() throws Throwable {
        int[] intArray0 = null;
        // Undeclared exception!
        try {
            Ints.sortDescending((int[]) null, 93, 3696);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     max() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test25() throws Throwable {
        int[] intArray0 = null;
        // Undeclared exception!
        try {
            Ints.max((int[]) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.primitives.Ints", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados. Além de verificar se sortDescending() chamada
    *     com argumentos ilegais lança uma IndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test26() throws Throwable {
        int[] intArray0 = new int[8];
        int int0 = 1147;
        intArray0[0] = 1147;
        intArray0[1] = 188;
        intArray0[2] = 0;
        intArray0[3] = 0;
        intArray0[4] = 1112;
        intArray0[5] = (-3424);
        int int1 = 65;
        intArray0[6] = 65;
        int int2 = 0;
        intArray0[7] = 0;
        Ints.sortDescending(intArray0);
        assertEquals(8, intArray0.length);
        assertArrayEquals(new int[]{1147, 1112, 188, 65, 0, 0, 0, (-3424)}, intArray0);

        Converter<String, Integer> converter0 = Ints.stringConverter();
        assertNotNull(converter0);

        int[] intArray1 = Ints.ensureCapacity(intArray0, 1112, 16);
        assertNotSame(intArray0, intArray1);
        assertNotSame(intArray1, intArray0);
        assertNotNull(intArray1);
        assertEquals(8, intArray0.length);
        assertEquals(1128, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray0));
        assertArrayEquals(new int[]{1147, 1112, 188, 65, 0, 0, 0, (-3424)}, intArray0);

        int int3 = Ints.indexOf(intArray0, intArray1);
        assertEquals((-1), int3);
        assertNotSame(intArray0, intArray1);
        assertNotSame(intArray1, intArray0);
        assertEquals(8, intArray0.length);
        assertEquals(1128, intArray1.length);
        assertFalse(intArray0.equals((Object) intArray1));
        assertFalse(intArray1.equals((Object) intArray0));
        assertFalse(int3 == int1);
        assertFalse(int3 == int0);
        assertFalse(int3 == int2);
        assertArrayEquals(new int[]{1147, 1112, 188, 65, 0, 0, 0, (-3424)}, intArray0);

        // Undeclared exception!
        try {
            Ints.sortDescending(intArray1, 1147, 0);
            fail("Expecting exception: IndexOutOfBoundsException");

        } catch (IndexOutOfBoundsException e) {
            //
            // start index (1147) must not be greater than size (1128)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     ensureCapacity() chamada com argumentos ilegais lança uma IllegalArgumentException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test29() throws Throwable {
        int[] intArray0 = null;
        int int0 = 640;
        // Undeclared exception!
        try {
            Ints.ensureCapacity((int[]) null, 640, (-3403));
            fail("Expecting exception: IllegalArgumentException");

        } catch (IllegalArgumentException e) {
            //
            // Invalid padding: -3403
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     tryParse() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test30() throws Throwable {
        int int0 = 0;
        int int1 = Ints.hashCode(0);
        assertTrue(int1 == int0);

        int int2 = Ints.checkedCast(0);
        assertEquals(0, int2);
        assertTrue(int2 == int0);

        int[] intArray0 = new int[2];
        intArray0[0] = 0;
        intArray0[1] = 0;
        boolean boolean0 = Ints.contains(intArray0, 0);
        assertTrue(boolean0);
        assertEquals(2, intArray0.length);
        assertArrayEquals(new int[]{0, 0}, intArray0);

        // Undeclared exception!
        try {
            Ints.tryParse((String) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, verifica
    *     se diversas variáveis e instâncias de Ints estão com valores iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test31() throws Throwable {
        byte[] byteArray0 = Ints.toByteArray(0);
        assertNotNull(byteArray0);
        assertEquals(4, byteArray0.length);
        assertArrayEquals(new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 0}, byteArray0);

        int[][] intArray0 = new int[2][5];
        int[] intArray1 = new int[7];
        intArray1[0] = 0;
        intArray1[1] = 0;
        intArray1[2] = 0;
        intArray1[3] = 0;
        intArray1[4] = 0;
        intArray1[5] = 0;
        intArray1[6] = 0;
        intArray0[0] = intArray1;
        int[] intArray2 = new int[5];
        assertFalse(intArray2.equals((Object) intArray1));

        intArray2[0] = 0;
        intArray2[1] = 0;
        intArray2[2] = 0;
        intArray2[3] = 352;
        intArray2[4] = 0;
        intArray0[1] = intArray2;
        int[] intArray3 = Ints.concat(intArray0);
        assertNotSame(intArray3, intArray2);
        assertNotSame(intArray3, intArray1);
        assertNotNull(intArray3);
        assertEquals(2, intArray0.length);
        assertEquals(12, intArray3.length);
        assertFalse(intArray3.equals((Object) intArray2));
        assertFalse(intArray3.equals((Object) intArray1));

        Ints.sortDescending(intArray1);
        assertNotSame(intArray1, intArray3);
        assertNotSame(intArray1, intArray2);
        assertEquals(7, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray3));
        assertFalse(intArray1.equals((Object) intArray2));
        assertArrayEquals(new int[]{0, 0, 0, 0, 0, 0, 0}, intArray1);

        int int0 = Ints.indexOf(intArray1, intArray1);
        assertEquals(0, int0);
        assertNotSame(intArray1, intArray3);
        assertNotSame(intArray1, intArray2);
        assertEquals(7, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray3));
        assertFalse(intArray1.equals((Object) intArray2));
        assertArrayEquals(new int[]{0, 0, 0, 0, 0, 0, 0}, intArray1);

        int int1 = Ints.hashCode(7);
        assertFalse(int1 == int0);

        int[] intArray4 = new int[6];
        assertFalse(intArray4.equals((Object) intArray2));
        assertFalse(intArray4.equals((Object) intArray3));
        assertFalse(intArray4.equals((Object) intArray1));

        intArray4[0] = (-2106);
        intArray4[1] = 0;
        intArray4[2] = 352;
        intArray4[3] = 352;
        intArray4[4] = 7;
        intArray4[5] = 0;
        int int2 = Ints.indexOf(intArray1, intArray4);
        assertEquals((-1), int2);
        assertNotSame(intArray1, intArray3);
        assertNotSame(intArray1, intArray2);
        assertNotSame(intArray1, intArray4);
        assertNotSame(intArray4, intArray2);
        assertNotSame(intArray4, intArray3);
        assertNotSame(intArray4, intArray1);
        assertEquals(7, intArray1.length);
        assertEquals(6, intArray4.length);
        assertFalse(intArray1.equals((Object) intArray3));
        assertFalse(intArray1.equals((Object) intArray2));
        assertFalse(intArray1.equals((Object) intArray4));
        assertFalse(intArray4.equals((Object) intArray2));
        assertFalse(intArray4.equals((Object) intArray3));
        assertFalse(intArray4.equals((Object) intArray1));
        assertFalse(int2 == int0);
        assertArrayEquals(new int[]{0, 0, 0, 0, 0, 0, 0}, intArray1);
        assertArrayEquals(new int[]{(-2106), 0, 352, 352, 7, 0}, intArray4);

        Ints.sortDescending(intArray1);
        assertNotSame(intArray1, intArray3);
        assertNotSame(intArray1, intArray2);
        assertNotSame(intArray1, intArray4);
        assertEquals(7, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray3));
        assertFalse(intArray1.equals((Object) intArray2));
        assertFalse(intArray1.equals((Object) intArray4));
        assertArrayEquals(new int[]{0, 0, 0, 0, 0, 0, 0}, intArray1);

        int int3 = Ints.lastIndexOf(intArray1, 352);
        assertEquals((-1), int3);
        assertNotSame(intArray1, intArray3);
        assertNotSame(intArray1, intArray2);
        assertNotSame(intArray1, intArray4);
        assertEquals(7, intArray1.length);
        assertFalse(intArray1.equals((Object) intArray3));
        assertFalse(intArray1.equals((Object) intArray2));
        assertFalse(intArray1.equals((Object) intArray4));
        assertTrue(int3 == int2);
        assertFalse(int3 == int0);
        assertArrayEquals(new int[]{0, 0, 0, 0, 0, 0, 0}, intArray1);

        byte[] byteArray1 = Ints.toByteArray((-2095));
        assertNotSame(byteArray1, byteArray0);
        assertNotNull(byteArray1);
        assertEquals(4, byteArray1.length);
        assertFalse(byteArray1.equals((Object) byteArray0));
        assertArrayEquals(new byte[]{(byte) (-1), (byte) (-1), (byte) (-9), (byte) (-47)}, byteArray1);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     reverse() chamada com argumentos ilegais lança uma IndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test32() throws Throwable {
        Integer integer0 = Ints.tryParse("fromIterable", 5);
        assertNull(integer0);

        int[] intArray0 = new int[8];
        intArray0[0] = 5;
        intArray0[1] = 5;
        intArray0[2] = 5;
        intArray0[3] = 5;
        intArray0[4] = 5;
        intArray0[5] = 5;
        intArray0[6] = 5;
        intArray0[7] = 5;
        // Undeclared exception!
        try {
            Ints.reverse(intArray0, 740, 5);
            fail("Expecting exception: IndexOutOfBoundsException");

        } catch (IndexOutOfBoundsException e) {
            //
            // start index (740) must not be greater than size (8)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     indexOf() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test36() throws Throwable {
        int[] intArray0 = null;
        int[] intArray1 = new int[5];
        intArray1[0] = (-1949);
        intArray1[1] = 0;
        intArray1[2] = 0;
        intArray1[3] = (-682);
        intArray1[4] = 56;
        // Undeclared exception!
        try {
            Ints.indexOf((int[]) null, intArray1);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // array
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     lastIndexOf() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test39() throws Throwable {
        int[] intArray0 = null;
        // Undeclared exception!
        try {
            Ints.lastIndexOf((int[]) null, 0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.primitives.Ints", e);
        }
    }

}
