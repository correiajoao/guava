/*
* This file was automatically generated by EvoSuite
* Thu Feb 27 02:36:29 GMT 2020
*/

package com.google.common.base;

import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.StringWriter;
import java.util.*;

import static org.evosuite.runtime.EvoAssertions.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.junit.Assert.*;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true)
public class Joiner_ESTest extends Joiner_ESTest_scaffolding {

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método useForNull() com parâmentros inválidos lança uma UnsupportedOperationException. Entretanto o
    *     teste possuí código que parece não contribuir para o objetivo final.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são parcialmente compreesíveis.
    */
    @Test(timeout = 4000)
    public void test00() throws Throwable {
        Joiner joiner0 = Joiner.on('>');
        String string0 = " P+]";
        Joiner joiner1 = joiner0.useForNull(" P+]");
        StringBuilder stringBuilder0 = new StringBuilder((CharSequence) " P+]");
        Iterator<String> iterator0 = (Iterator<String>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        doReturn(true, false).when(iterator0).hasNext();
        doReturn((Object) null).when(iterator0).next();
        StringBuilder stringBuilder1 = joiner1.appendTo(stringBuilder0, iterator0);
        Joiner.MapJoiner joiner_MapJoiner0 = joiner1.withKeyValueSeparator(string0);
        int int0 = 1576;
        Vector<StringBuffer> vector0 = new Vector<StringBuffer>(int0);
        joiner0.appendTo(stringBuilder1, (Iterable<?>) vector0);
        String string1 = null;
        // Undeclared exception!
        try {
            joiner_MapJoiner0.useForNull(string1);
            fail("Expecting exception: UnsupportedOperationException");

        } catch (UnsupportedOperationException e) {
            //
            // already specified useForNull
            //
            verifyException("com.google.common.base.Joiner$1", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste não é compreensível, já suas instruções são parcialmente compreesíveis.
    */

    @Test(timeout = 4000)
    public void test01() throws Throwable {
        char char0 = '3';
        Joiner joiner0 = Joiner.on('3');
        Joiner.MapJoiner joiner_MapJoiner0 = joiner0.withKeyValueSeparator('3');
        Joiner.MapJoiner joiner_MapJoiner1 = joiner_MapJoiner0.useForNull("");
        StringBuilder stringBuilder0 = new StringBuilder();
        Vector<Integer> vector0 = new Vector<Integer>();
        PriorityQueue<Integer> priorityQueue0 = new PriorityQueue<Integer>(vector0);
        StringBuilder stringBuilder1 = joiner0.appendTo(stringBuilder0, (Iterable<?>) priorityQueue0);
        Object[] objectArray0 = new Object[9];
        objectArray0[0] = (Object) stringBuilder1;
        objectArray0[1] = (Object) stringBuilder1;
        objectArray0[2] = (Object) stringBuilder0;
        objectArray0[3] = (Object) vector0;
        objectArray0[4] = (Object) priorityQueue0;
        objectArray0[5] = (Object) joiner_MapJoiner1;
        objectArray0[6] = (Object) joiner_MapJoiner0;
        objectArray0[7] = (Object) priorityQueue0;
        objectArray0[8] = (Object) stringBuilder0;
        StringBuilder stringBuilder2 = joiner0.appendTo(stringBuilder1, objectArray0);
        HashSet<Map.Entry<StringBuilder, String>> hashSet0 = new HashSet<Map.Entry<StringBuilder, String>>();
        joiner_MapJoiner0.appendTo(stringBuilder2, (Iterable<? extends Map.Entry<?, ?>>) hashSet0);
        HashMap<StringBuffer, Object> hashMap0 = new HashMap<StringBuffer, Object>();
        StringBuffer stringBuffer0 = new StringBuffer("");
        Locale.Category locale_Category0 = Locale.Category.FORMAT;
        hashMap0.put(stringBuffer0, locale_Category0);
        joiner_MapJoiner1.join((Map<?, ?>) hashMap0);
        joiner_MapJoiner1.join((Map<?, ?>) hashMap0);
        Object[] objectArray1 = new Object[3];
        objectArray1[0] = (Object) joiner0;
        objectArray1[1] = (Object) "3java.util.Locale$Category@0000000007";
        objectArray1[2] = null;
        // Undeclared exception!
        try {
            joiner0.join(objectArray1);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test02() throws Throwable {
        Joiner joiner0 = Joiner.on("");
        Joiner.MapJoiner joiner_MapJoiner0 = joiner0.withKeyValueSeparator('w');
        Joiner.MapJoiner joiner_MapJoiner1 = joiner_MapJoiner0.useForNull("");
        StringBuffer stringBuffer0 = new StringBuffer();
        StringBuffer stringBuffer1 = stringBuffer0.append((-1));
        StringBuffer stringBuffer2 = stringBuffer1.append((CharSequence) "");
        Object object0 = new Object();
        Object[] objectArray0 = new Object[7];
        objectArray0[0] = (Object) objectArray0;
        objectArray0[1] = (Object) stringBuffer2;
        objectArray0[2] = objectArray0[1];
        objectArray0[4] = (Object) "";
        objectArray0[5] = objectArray0[4];
        objectArray0[6] = (Object) stringBuffer0;
        StringBuilder stringBuilder0 = new StringBuilder("");
        Iterator<Map.Entry<StringBuffer, StringBuffer>> iterator0 = (Iterator<Map.Entry<StringBuffer, StringBuffer>>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        doReturn(false).when(iterator0).hasNext();
        joiner_MapJoiner0.appendTo(stringBuffer2, (Iterator<? extends Map.Entry<?, ?>>) iterator0);
        Map.Entry<StringBuilder, String> map_Entry0 = (Map.Entry<StringBuilder, String>) mock(Map.Entry.class, new ViolatedAssumptionAnswer());
        doReturn((Object) null).when(map_Entry0).getKey();
        doReturn((Object) null).when(map_Entry0).getValue();
        Map.Entry<StringBuilder, String> map_Entry1 = (Map.Entry<StringBuilder, String>) mock(Map.Entry.class, new ViolatedAssumptionAnswer());
        Iterator<Map.Entry<StringBuilder, String>> iterator1 = (Iterator<Map.Entry<StringBuilder, String>>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        doReturn(true, false).when(iterator1).hasNext();
        doReturn(map_Entry0).when(iterator1).next();
        String string0 = joiner_MapJoiner1.join(iterator1);
        assertEquals("w", string0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test03() throws Throwable {
        Joiner joiner0 = Joiner.on('i');
        Object[] objectArray0 = new Object[0];
        joiner0.join(objectArray0);
        StringBuilder stringBuilder0 = new StringBuilder((CharSequence) "");
        int int0 = 0;
        Object object0 = new Object();
        StringBuilder stringBuilder1 = stringBuilder0.insert(0, object0);
        char[] charArray0 = new char[6];
        charArray0[0] = 'i';
        charArray0[1] = 'i';
        charArray0[2] = 'i';
        charArray0[3] = 'i';
        charArray0[4] = 'i';
        charArray0[5] = 'i';
        int int1 = 1682554634;
        // Undeclared exception!
        try {
            stringBuilder1.insert(13, charArray0, 0, 1682554634);
            fail("Expecting exception: StringIndexOutOfBoundsException");

        } catch (StringIndexOutOfBoundsException e) {
            //
            // offset 0, len 1682554634, str.length 6
            //
            verifyException("java.lang.AbstractStringBuilder", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método appendTo() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test04() throws Throwable {
        String string0 = "MzBp5e?5";
        Iterator<Integer> iterator0 = (Iterator<Integer>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        doReturn(true).when(iterator0).hasNext();
        doReturn((Object) null).when(iterator0).next();
        Joiner joiner0 = Joiner.on('8');
        Joiner joiner1 = joiner0.skipNulls();
        joiner1.skipNulls();
        Joiner joiner2 = Joiner.on("com.google.common.base.CaseFormat$StringConverter");
        StringWriter stringWriter0 = new StringWriter();
        StringBuffer stringBuffer0 = stringWriter0.getBuffer();
        // Undeclared exception!
        try {
            joiner2.appendTo(stringBuffer0, (Iterator<?>) iterator0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test06() throws Throwable {
        Iterator<Integer> iterator0 = (Iterator<Integer>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        Object[] objectArray0 = new Object[6];
        objectArray0[0] = (Object) null;
        objectArray0[3] = (Object) null;
        Object object0 = new Object();
        objectArray0[5] = object0;
        HashMap<StringBuffer, StringBuilder> hashMap0 = new HashMap<StringBuffer, StringBuilder>();
        Integer integer0 = new Integer(0);
        Object[] objectArray1 = new Object[4];
        Object object1 = new Object();
        objectArray1[2] = object1;
        Joiner joiner0 = Joiner.on("u:4q1D/bjH?");
        LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
        Locale locale0 = Locale.forLanguageTag("}BnDl62d");
        Locale locale1 = locale0.stripExtensions();
        Set<String> set0 = locale1.getUnicodeLocaleAttributes();
        Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.AUTOSELECT_FILTERING;
        List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0, locale_FilteringMode0);
        // Undeclared exception!
        try {
            joiner0.appendTo((StringBuffer) null, (Iterable<?>) list0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test07() throws Throwable {
        Joiner joiner0 = Joiner.on(';');
        Joiner joiner1 = joiner0.useForNull("");
        Iterator<String> iterator0 = (Iterator<String>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        doReturn(true, true, false).when(iterator0).hasNext();
        doReturn("", "").when(iterator0).next();
        joiner1.join(iterator0);
        ArrayList<String> arrayList0 = new ArrayList<String>(656);
        joiner0.join((Iterable<?>) arrayList0);
        Vector<Object> vector0 = new Vector<Object>(656);
        Integer integer0 = new Integer(3308);
        vector0.add((Object) integer0);
        vector0.clone();
        vector0.add((Object) joiner1);
        joiner1.join((Iterable<?>) vector0);
        Joiner joiner2 = Joiner.on(';');
        assertNotSame(joiner2, joiner0);
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método join() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test08() throws Throwable {
        char char0 = ',';
        Joiner joiner0 = Joiner.on(',');
        joiner0.withKeyValueSeparator('4');
        Iterator<Integer> iterator0 = (Iterator<Integer>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        doReturn(true).when(iterator0).hasNext();
        doReturn((Object) null).when(iterator0).next();
        // Undeclared exception!
        try {
            joiner0.join(iterator0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test09() throws Throwable {
        Joiner joiner0 = Joiner.on("/'!rNc [P~");
        Joiner joiner1 = joiner0.useForNull("/'!rNc [P~");
        StringBuffer stringBuffer0 = new StringBuffer("HJ`-M$$=X$3T");
        StringBuffer stringBuffer1 = stringBuffer0.delete(0, 11);
        Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
        PriorityQueue<Object> priorityQueue0 = new PriorityQueue<Object>(11, comparator0);
        HashSet<Object> hashSet0 = new HashSet<Object>();
        priorityQueue0.addAll(hashSet0);
        Iterator<Object> iterator0 = priorityQueue0.iterator();
        joiner1.appendTo(stringBuffer1, (Iterator<?>) iterator0);
        ArrayList<Object> arrayList0 = new ArrayList<Object>(0);
        joiner1.join((Iterable<?>) arrayList0);
        StringBuilder stringBuilder0 = new StringBuilder((CharSequence) "");
        StringBuilder stringBuilder1 = joiner0.appendTo(stringBuilder0, (Iterable<?>) arrayList0);
        Object object0 = new Object();
        Object[] objectArray0 = new Object[5];
        objectArray0[0] = (Object) stringBuilder0;
        objectArray0[1] = (Object) "/'!rNc [P~";
        arrayList0.add((Object) "/'!rNc [P~");
        objectArray0[2] = (Object) joiner0;
        objectArray0[3] = objectArray0[2];
        objectArray0[4] = (Object) "";
        joiner0.appendTo(stringBuilder0, (Object) stringBuilder1, object0, objectArray0);
        Joiner joiner2 = Joiner.on("");
        assertFalse(joiner2.equals((Object) joiner1));
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test10() throws Throwable {
        String string0 = "AoE*a\"LRD\\Pzh>";
        Joiner joiner0 = Joiner.on("AoE*a\"LRDPzh>");
        Joiner joiner1 = joiner0.useForNull("AoE*a\"LRDPzh>");
        Iterator<String> iterator0 = (Iterator<String>) mock(Iterator.class, new ViolatedAssumptionAnswer());
        doReturn(true, false).when(iterator0).hasNext();
        doReturn((Object) null).when(iterator0).next();
        char char0 = '\\';
        Joiner.on('\\');
        String string1 = joiner1.join(iterator0);
        Object[] objectArray0 = new Object[6];
        objectArray0[0] = (Object) string1;
        objectArray0[1] = (Object) joiner1;
        objectArray0[2] = (Object) string0;
        Object object0 = new Object();
        PriorityQueue<Object> priorityQueue0 = new PriorityQueue<Object>();
        priorityQueue0.add(string0);
        Integer integer0 = new Integer(char0);
        Integer.toUnsignedLong(char0);
        // Undeclared exception!
        try {
            priorityQueue0.add(integer0);
            fail("Expecting exception: ClassCastException");

        } catch (ClassCastException e) {
            //
            // java.lang.String cannot be cast to java.lang.Integer
            //
            verifyException("java.lang.Integer", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test12() throws Throwable {
        Joiner joiner0 = Joiner.on('M');
        Joiner.MapJoiner joiner_MapJoiner0 = joiner0.withKeyValueSeparator('M');
        Joiner joiner1 = joiner0.skipNulls();
        Object[] objectArray0 = new Object[8];
        objectArray0[0] = (Object) joiner1;
        objectArray0[2] = (Object) joiner_MapJoiner0;
        objectArray0[3] = (Object) joiner0;
        StringBuilder stringBuilder0 = new StringBuilder();
        StringBuilder stringBuilder1 = new StringBuilder(stringBuilder0);
        Integer integer0 = new Integer(2);
        StringBuilder stringBuilder2 = joiner1.appendTo(stringBuilder1, (Object) integer0, objectArray0[0], objectArray0);
        PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>(6);
        StringBuilder stringBuilder3 = joiner0.appendTo(stringBuilder2, (Iterable<?>) priorityQueue0);
        objectArray0[4] = (Object) joiner0;
        objectArray0[5] = (Object) joiner_MapJoiner0;
        objectArray0[6] = (Object) joiner0;
        char[] charArray0 = new char[8];
        charArray0[0] = 'M';
        charArray0[1] = 'M';
        charArray0[2] = 'L';
        charArray0[3] = 'M';
        charArray0[4] = 'M';
        charArray0[5] = 'M';
        charArray0[6] = 'M';
        charArray0[7] = 'w';
        HashMap<String, String> hashMap0 = new HashMap<String, String>();
        Integer.getInteger("com.google.common.base.Joiner", (Integer) null);
        StringBuilder stringBuilder4 = joiner1.appendTo(stringBuilder1, (Object) null, objectArray0[6], objectArray0);
        assertSame(stringBuilder4, stringBuilder3);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método toString() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test13() throws Throwable {
        Joiner joiner0 = Joiner.on('O');
        // Undeclared exception!
        try {
            joiner0.toString((Object) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método join() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test14() throws Throwable {
        Joiner joiner0 = Joiner.on("@N|K ^");
        HashSet<Integer> hashSet0 = new HashSet<Integer>();
        joiner0.useForNull("");
        hashSet0.add((Integer) null);
        // Undeclared exception!
        try {
            joiner0.join((Iterable<?>) hashSet0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método appendTo() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test15() throws Throwable {
        String string0 = ";NZm\"CXp7izYr1\"u0[";
        Joiner joiner0 = Joiner.on(";NZm\"CXp7izYr1\"u0[");
        joiner0.skipNulls();
        Object[] objectArray0 = new Object[2];
        StringBuilder stringBuilder0 = new StringBuilder();
        // Undeclared exception!
        try {
            joiner0.appendTo(stringBuilder0, objectArray0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método join() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test17() throws Throwable {
        Joiner joiner0 = Joiner.on("");
        Joiner joiner1 = joiner0.skipNulls();
        StringBuffer stringBuffer0 = new StringBuffer((CharSequence) "");
        ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>();
        LinkedList<String> linkedList0 = new LinkedList<String>(arrayDeque0);
        joiner1.join((Iterable<?>) linkedList0);
        // Undeclared exception!
        try {
            joiner1.appendTo(stringBuffer0, (Iterator<?>) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // parts
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test18() throws Throwable {
        Joiner joiner0 = Joiner.on('q');
        Joiner joiner1 = joiner0.useForNull("already specified skipNulls");
        Stack<Locale.LanguageRange> stack0 = new Stack<Locale.LanguageRange>();
        ArrayList<String> arrayList0 = new ArrayList<String>();
        List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) stack0, (Collection<String>) arrayList0);
        String string0 = joiner1.join((Iterable<?>) list0);
        Joiner.MapJoiner joiner_MapJoiner0 = joiner1.withKeyValueSeparator("");
        Vector<Map.Entry<Integer, Object>> vector0 = new Vector<Map.Entry<Integer, Object>>();
        joiner_MapJoiner0.join((Iterable<? extends Map.Entry<?, ?>>) vector0);
        StringBuffer stringBuffer0 = new StringBuffer(0);
        HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
        StringBuffer stringBuffer1 = joiner_MapJoiner0.appendTo(stringBuffer0, (Map<?, ?>) hashMap0);
        Object[] objectArray0 = new Object[9];
        objectArray0[0] = (Object) joiner0;
        objectArray0[1] = (Object) joiner_MapJoiner0;
        objectArray0[2] = (Object) joiner0;
        objectArray0[3] = (Object) joiner1;
        objectArray0[4] = (Object) joiner1;
        objectArray0[5] = (Object) vector0;
        objectArray0[6] = (Object) "already specified skipNulls";
        objectArray0[7] = (Object) joiner0;
        objectArray0[8] = (Object) stringBuffer1;
        String string1 = joiner1.join(objectArray0);
        assertFalse(string1.equals((Object) string0));
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método join() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test19() throws Throwable {
        String string0 = "";
        Joiner joiner0 = Joiner.on("");
        joiner0.skipNulls();
        Iterator<StringBuffer> iterator0 = null;
        // Undeclared exception!
        try {
            joiner0.join((Iterator<?>) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Joiner", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método appendTo() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test20() throws Throwable {
        String string0 = "Wh.uSF*`|R7'],H";
        Joiner joiner0 = Joiner.on("Wh.uSF*`|R7'],H");
        Object object0 = new Object();
        Object[] objectArray0 = new Object[7];
        Joiner.on("Wh.uSF*`|R7'],H");
        objectArray0[0] = object0;
        objectArray0[1] = (Object) "Wh.uSF*`|R7'],H";
        objectArray0[2] = object0;
        objectArray0[3] = object0;
        objectArray0[4] = (Object) joiner0;
        objectArray0[5] = object0;
        Joiner.MapJoiner joiner_MapJoiner0 = joiner0.withKeyValueSeparator("Wh.uSF*`|R7'],H");
        objectArray0[6] = (Object) "Wh.uSF*`|R7'],H";
        joiner0.join((Object) "Wh.uSF*`|R7'],H", object0, objectArray0);
        // Undeclared exception!
        try {
            joiner0.appendTo((StringBuffer) null, (Object) joiner_MapJoiner0, (Object) "Wh.uSF*`|R7'],HWh.uSF*`|R7'],Hjava.lang.Object@0000000005Wh.uSF*`|R7'],Hjava.lang.Object@0000000005Wh.uSF*`|R7'],HWh.uSF*`|R7'],HWh.uSF*`|R7'],Hjava.lang.Object@0000000005Wh.uSF*`|R7'],Hjava.lang.Object@0000000005Wh.uSF*`|R7'],Hcom.google.common.base.Joiner@0000000001Wh.uSF*`|R7'],Hjava.lang.Object@0000000005Wh.uSF*`|R7'],HWh.uSF*`|R7'],H", objectArray0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método appendTo() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são parcialmente compreesíveis.
    */
    @Test(timeout = 4000)
    public void test22() throws Throwable {
        String string0 = "";
        Joiner joiner0 = Joiner.on("");
        StringBuilder stringBuilder0 = null;
        int int0 = 0;
        Vector<Integer> vector0 = new Vector<Integer>(0, 8232);
        joiner0.join((Iterable<?>) vector0);
        Object[] objectArray0 = new Object[1];
        objectArray0[0] = (Object) "";
        // Undeclared exception!
        try {
            joiner0.appendTo((StringBuilder) null, objectArray0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test23() throws Throwable {
        Joiner joiner0 = Joiner.on('`');
        Joiner.MapJoiner joiner_MapJoiner0 = joiner0.withKeyValueSeparator('`');
        Joiner.MapJoiner joiner_MapJoiner1 = joiner_MapJoiner0.useForNull("tFk=&={:=P");
        StringBuilder stringBuilder0 = new StringBuilder((CharSequence) "tFk=&={:=P");
        HashMap<Integer, Object> hashMap0 = new HashMap<Integer, Object>();
        StringBuilder stringBuilder1 = joiner_MapJoiner1.appendTo(stringBuilder0, (Map<?, ?>) hashMap0);
        Integer integer0 = new Integer((-524));
        Object[] objectArray0 = new Object[9];
        objectArray0[0] = (Object) joiner_MapJoiner0;
        objectArray0[1] = (Object) integer0;
        objectArray0[2] = (Object) joiner_MapJoiner1;
        objectArray0[3] = (Object) stringBuilder1;
        objectArray0[4] = (Object) joiner_MapJoiner0;
        objectArray0[5] = (Object) joiner0;
        objectArray0[6] = (Object) "tFk=&={:=P";
        objectArray0[7] = (Object) stringBuilder1;
        objectArray0[8] = (Object) stringBuilder1;
        String string0 = joiner0.join((Object) stringBuilder1, (Object) integer0, objectArray0);
        assertNotNull(string0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método useForNull() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test24() throws Throwable {
        Joiner joiner0 = Joiner.on('c');
        String string0 = null;
        // Undeclared exception!
        try {
            joiner0.useForNull((String) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método appendTo() com parâmentros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test25() throws Throwable {
        Joiner joiner0 = Joiner.on('y');
        joiner0.withKeyValueSeparator("yoaS<");
        StringBuffer stringBuffer0 = new StringBuffer("yoaS<");
        StringBuffer stringBuffer1 = stringBuffer0.append("yoaS<");
        StringBuffer stringBuffer2 = stringBuffer1.append(stringBuffer0);
        // Undeclared exception!
        try {
            joiner0.appendTo(stringBuffer2, (Iterable<?>) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Joiner", e);
        }
    }
}
