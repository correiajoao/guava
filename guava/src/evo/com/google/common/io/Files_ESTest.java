/*
* This file was automatically generated by EvoSuite
* Wed Feb 26 17:32:43 GMT 2020
*/

package com.google.common.io;

import com.google.common.hash.HashCode;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hasher;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.mock.java.net.MockURI;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.*;
import java.net.URI;
import java.nio.CharBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;
import java.util.LinkedList;

import static org.evosuite.runtime.EvoAssertions.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.junit.Assert.*;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true)
public class Files_ESTest extends Files_ESTest_scaffolding {

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O único comportamento verificado pelo teste é se ele pode ser executado no tempo de 4s; Porém o teste é
    *     complexo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test000() throws Throwable {
        Files.getNameWithoutExtension("IS_FILE");
        File file0 = MockFile.createTempFile("IS_FILE", "4tQ(4H#8$~<T");
        FileChannel.MapMode fileChannel_MapMode0 = FileChannel.MapMode.PRIVATE;
        MappedByteBuffer mappedByteBuffer0 = Files.map(file0, fileChannel_MapMode0, 3160L);
        Charset charset0 = Charset.defaultCharset();
        CharBuffer charBuffer0 = charset0.decode(mappedByteBuffer0);
        FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
        Files.readFirstLine(file0, charset0);
        Files.readFirstLine(file0, charset0);
        Files.map(file0, fileChannel_MapMode0);
        Files.copy(file0, charset0, (Appendable) charBuffer0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     os valores do File são iguais aos esperados. Por fim existe um trecho de dificil compreensão, o que torna o teste
    *     complexo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test001() throws Throwable {
        byte[] byteArray0 = new byte[3];
        byteArray0[0] = (byte) 3;
        byteArray0[1] = (byte) (-122);
        byteArray0[2] = (byte) (-5);
        MockFile mockFile0 = new MockFile("Zu7R$V");
        assertNotNull(mockFile0);

        File file0 = mockFile0.getAbsoluteFile();
        assertNotNull(file0);
        assertFalse(mockFile0.exists());
        assertNull(mockFile0.getParent());
        assertEquals(0L, mockFile0.getUsableSpace());
        assertFalse(mockFile0.isHidden());
        assertEquals(0L, mockFile0.length());
        assertFalse(mockFile0.isAbsolute());
        assertEquals("Zu7R$V", mockFile0.getName());
        assertEquals(0L, mockFile0.lastModified());
        assertFalse(mockFile0.isDirectory());
        assertEquals(0L, mockFile0.getFreeSpace());
        assertFalse(mockFile0.canWrite());
        assertFalse(mockFile0.canRead());
        assertEquals("Zu7R$V", mockFile0.toString());
        assertEquals(0L, mockFile0.getTotalSpace());
        assertFalse(mockFile0.canExecute());
        assertTrue(mockFile0.isFile());
        assertFalse(file0.isHidden());
        assertEquals(0L, file0.lastModified());
        assertEquals(0L, file0.getUsableSpace());
        assertFalse(file0.canWrite());
        assertEquals("/Users/joaocorreia/guava/guava", file0.getParent());
        assertTrue(file0.isFile());
        assertFalse(file0.canExecute());
        assertEquals(0L, file0.getFreeSpace());
        assertEquals(0L, file0.length());
        assertEquals("/Users/joaocorreia/guava/guava/Zu7R$V", file0.toString());
        assertEquals(0L, file0.getTotalSpace());
        assertFalse(file0.isDirectory());
        assertFalse(file0.canRead());
        assertFalse(file0.exists());
        assertTrue(file0.isAbsolute());
        assertEquals("Zu7R$V", file0.getName());
        assertFalse(file0.equals((Object) mockFile0));
        assertNotSame(mockFile0, file0);
        assertNotSame(file0, mockFile0);

        Files.write(byteArray0, file0);
        assertEquals(3, byteArray0.length);
        assertEquals(3L, mockFile0.length());
        assertNull(mockFile0.getParent());
        assertEquals(0L, mockFile0.getUsableSpace());
        assertFalse(mockFile0.isHidden());
        assertFalse(mockFile0.isAbsolute());
        assertEquals("Zu7R$V", mockFile0.getName());
        assertFalse(mockFile0.isDirectory());
        assertEquals(0L, mockFile0.getFreeSpace());
        assertTrue(mockFile0.canWrite());
        assertEquals("Zu7R$V", mockFile0.toString());
        assertTrue(mockFile0.canExecute());
        assertEquals(1392409281320L, mockFile0.lastModified());
        assertEquals(0L, mockFile0.getTotalSpace());
        assertTrue(mockFile0.canRead());
        assertTrue(mockFile0.exists());
        assertTrue(mockFile0.isFile());
        assertFalse(file0.isHidden());
        assertTrue(file0.canWrite());
        assertEquals(0L, file0.getUsableSpace());
        assertTrue(file0.canExecute());
        assertEquals("/Users/joaocorreia/guava/guava", file0.getParent());
        assertTrue(file0.canRead());
        assertTrue(file0.isFile());
        assertEquals(1392409281320L, file0.lastModified());
        assertEquals(0L, file0.getFreeSpace());
        assertTrue(file0.exists());
        assertEquals("/Users/joaocorreia/guava/guava/Zu7R$V", file0.toString());
        assertEquals(0L, file0.getTotalSpace());
        assertFalse(file0.isDirectory());
        assertEquals(3L, file0.length());
        assertTrue(file0.isAbsolute());
        assertEquals("Zu7R$V", file0.getName());
        assertTrue(mockFile0.equals((Object) file0));
        assertFalse(file0.equals((Object) mockFile0));
        assertArrayEquals(new byte[]{(byte) 3, (byte) (-122), (byte) (-5)}, byteArray0);
        assertNotSame(mockFile0, file0);
        assertNotSame(file0, mockFile0);

        MockPrintStream mockPrintStream0 = new MockPrintStream(file0);
        file0.mkdir();
        PrintStream printStream0 = mockPrintStream0.append((CharSequence) "Zu7R$V");
        Files.copy(file0, (OutputStream) printStream0);
        Charset charset0 = Charset.defaultCharset();
        LineProcessor<Object> lineProcessor0 = (LineProcessor<Object>) mock(LineProcessor.class, new ViolatedAssumptionAnswer());
        doReturn((Object) null).when(lineProcessor0).getResult();
        doReturn(false).when(lineProcessor0).processLine(anyString());
        Files.readLines(file0, charset0, lineProcessor0);
        Files.equal(file0, file0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O único comportamento verificado pelo teste é se ele pode ser executado no tempo de 4s; O que não parece
    *     viável para um teste que apenas instancia obejtos.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test002() throws Throwable {
        MockFile mockFile0 = new MockFile("/..");
        mockFile0.toPath();
        Files.createParentDirs(mockFile0);
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     hash() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test003() throws Throwable {
        FileSystemHandling.shouldAllThrowIOExceptions();
        System.setCurrentTimeMillis((-2003L));
        File file0 = Files.createTempDir();
        HashFunction hashFunction0 = mock(HashFunction.class, new ViolatedAssumptionAnswer());
        doReturn((Hasher) null).when(hashFunction0).newHasher();
        // Undeclared exception!
        try {
            Files.hash(file0, hashFunction0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     toString() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test004() throws Throwable {
        Files.simplifyPath("E");
        MockFile mockFile0 = new MockFile("E");
        Charset charset0 = Charset.defaultCharset();
        Files.append("E", mockFile0, charset0);
        Files.isDirectory();
        Files.getFileExtension("E");
        FileWriteMode[] fileWriteModeArray0 = new FileWriteMode[6];
        FileWriteMode fileWriteMode0 = FileWriteMode.APPEND;
        fileWriteModeArray0[0] = fileWriteMode0;
        FileWriteMode fileWriteMode1 = FileWriteMode.APPEND;
        fileWriteModeArray0[1] = fileWriteMode1;
        FileWriteMode fileWriteMode2 = FileWriteMode.APPEND;
        fileWriteModeArray0[2] = fileWriteMode2;
        FileWriteMode fileWriteMode3 = FileWriteMode.APPEND;
        fileWriteModeArray0[3] = fileWriteMode3;
        FileWriteMode fileWriteMode4 = FileWriteMode.APPEND;
        fileWriteModeArray0[4] = fileWriteMode4;
        FileWriteMode fileWriteMode5 = FileWriteMode.APPEND;
        fileWriteModeArray0[5] = fileWriteMode5;
        Files.asByteSink(mockFile0, fileWriteModeArray0);
        Charset charset1 = mock(Charset.class, new ViolatedAssumptionAnswer());
        doReturn((CharsetDecoder) null).when(charset1).newDecoder();
        // Undeclared exception!
        try {
            Files.toString((File) mockFile0, charset1);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O único comportamento verificado pelo teste é se ele pode ser executado no tempo de 4s; Porém o teste é
    *     complexo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test005() throws Throwable {
        Files.isDirectory();
        MockFile mockFile0 = new MockFile("X<VU");
        mockFile0.getCanonicalFile();
        EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("X<VU");
        byte[] byteArray0 = new byte[8];
        byteArray0[0] = (byte) 94;
        byteArray0[1] = (byte) (-2);
        byteArray0[2] = (byte) 108;
        byteArray0[3] = (byte) 47;
        byteArray0[4] = (byte) 92;
        byteArray0[5] = (byte) 74;
        byteArray0[6] = (byte) (-55);
        byteArray0[7] = (byte) (-88);
        FileSystemHandling.appendDataToFile(evoSuiteFile0, byteArray0);
        MockFile.createTempFile("X<VU", "GOJ");
        FileSystemHandling.createFolder(evoSuiteFile0);
        FileChannel.MapMode fileChannel_MapMode0 = FileChannel.MapMode.READ_WRITE;
        Files.map((File) mockFile0, fileChannel_MapMode0, 1704L);
        Files.copy((File) mockFile0, (File) mockFile0);
        MockFile mockFile1 = new MockFile("X<VU");
        Charset charset0 = Charset.defaultCharset();
        Files.append("X<VU", mockFile1, charset0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     write() chamada com argumentos ilegais lança uma IOException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test006() throws Throwable {
        byte[] byteArray0 = new byte[3];
        byteArray0[0] = (byte) 3;
        EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("Zu7R$V");
        FileSystemHandling.shouldThrowIOException(evoSuiteFile0);
        byteArray0[1] = (byte) (-122);
        byteArray0[2] = (byte) (-5);
        MockFile mockFile0 = new MockFile("Zu7R$V");
        File file0 = mockFile0.getAbsoluteFile();
        try {
            Files.write(byteArray0, file0);
            fail("Expecting exception: IOException");

        } catch (IOException e) {
            //
            // Simulated IOException
            //
            verifyException("org.evosuite.runtime.vfs.VirtualFileSystem", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test007() throws Throwable {
        Files.isDirectory();
        String string0 = "X<VU";
        MockFile mockFile0 = new MockFile("X<VU");
        File file0 = mockFile0.getCanonicalFile();
        File file1 = MockFile.createTempFile("X<VU", "GOJ");
        file1.toURL();
        Files.touch(mockFile0);
        Files.equal(file0, file1);
        Files.copy((File) mockFile0, (File) mockFile0);
        Files.createTempDir();
        // Undeclared exception!
        try {
            Charset.forName("X<VU");
            fail("Expecting exception: IllegalCharsetNameException");

        } catch (IllegalCharsetNameException e) {
            //
            // X<VU
            //
            verifyException("java.nio.charset.Charset", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O único comportamento verificado pelo teste é se ele pode ser executado no tempo de 4s; Porém o teste é
    *     complexo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test008() throws Throwable {
        FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
        Files.getFileExtension("I?O\"D9^I1C)7+:iF");
        URI uRI0 = MockURI.aFileURI;
        MockFile mockFile0 = new MockFile(uRI0);
        FileChannel.MapMode fileChannel_MapMode0 = FileChannel.MapMode.PRIVATE;
        Files.map((File) mockFile0, fileChannel_MapMode0);
        Files.createParentDirs(mockFile0);
        ByteProcessor<File> byteProcessor0 = (ByteProcessor<File>) mock(ByteProcessor.class, new ViolatedAssumptionAnswer());
        doReturn(mockFile0).when(byteProcessor0).getResult();
        MockFile mockFile1 = (MockFile) Files.readBytes((File) mockFile0, byteProcessor0);
        Charset charset0 = Charset.defaultCharset();
        Files.asCharSource(mockFile1, charset0);
        Files.newReader(mockFile0, charset0);
        FileWriteMode[] fileWriteModeArray0 = new FileWriteMode[9];
        FileWriteMode fileWriteMode0 = FileWriteMode.APPEND;
        fileWriteModeArray0[0] = fileWriteMode0;
        FileWriteMode fileWriteMode1 = FileWriteMode.APPEND;
        fileWriteModeArray0[1] = fileWriteMode1;
        FileWriteMode fileWriteMode2 = FileWriteMode.APPEND;
        fileWriteModeArray0[2] = fileWriteMode2;
        FileWriteMode fileWriteMode3 = FileWriteMode.APPEND;
        fileWriteModeArray0[3] = fileWriteMode3;
        FileWriteMode fileWriteMode4 = FileWriteMode.APPEND;
        fileWriteModeArray0[4] = fileWriteMode4;
        FileWriteMode fileWriteMode5 = FileWriteMode.APPEND;
        fileWriteModeArray0[5] = fileWriteMode5;
        FileWriteMode fileWriteMode6 = FileWriteMode.APPEND;
        fileWriteModeArray0[6] = fileWriteMode6;
        FileWriteMode fileWriteMode7 = FileWriteMode.APPEND;
        fileWriteModeArray0[7] = fileWriteMode7;
        FileWriteMode fileWriteMode8 = FileWriteMode.APPEND;
        fileWriteModeArray0[8] = fileWriteMode8;
        Files.asCharSink(mockFile0, charset0, fileWriteModeArray0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     asCharSink() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test009() throws Throwable {
        File file0 = Files.createTempDir();
        Charset charset0 = mock(Charset.class, new ViolatedAssumptionAnswer());
        FileChannel.MapMode fileChannel_MapMode0 = mock(FileChannel.MapMode.class, new ViolatedAssumptionAnswer());
        Files.map(file0, fileChannel_MapMode0);
        Files.createTempDir();
        File file1 = MockFile.createTempFile("@Z=D23!S1Y", "{^^&&{'<@8@F4(i", file0);
        // Undeclared exception!
        try {
            Files.asCharSink(file1, (Charset) null, (FileWriteMode[]) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.collect.ImmutableSet", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     asCharSource() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test010() throws Throwable {
        FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
        Files.getFileExtension("I?O\"D9^I1C)7+:iF");
        URI uRI0 = MockURI.aFileURI;
        MockFile mockFile0 = new MockFile(uRI0);
        FileChannel.MapMode fileChannel_MapMode0 = FileChannel.MapMode.PRIVATE;
        Files.map((File) mockFile0, fileChannel_MapMode0);
        Files.createParentDirs(mockFile0);
        ByteProcessor<File> byteProcessor0 = (ByteProcessor<File>) mock(ByteProcessor.class, new ViolatedAssumptionAnswer());
        doReturn((Object) null).when(byteProcessor0).getResult();
        Files.readBytes((File) mockFile0, byteProcessor0);
        Charset charset0 = Charset.defaultCharset();
        // Undeclared exception!
        try {
            Files.asCharSource((File) null, charset0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     equal() chamada com argumentos ilegais lança uma FileNotFoundException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test011() throws Throwable {
        Files.isDirectory();
        String string0 = "X<VU";
        MockFile mockFile0 = new MockFile("X<VU");
        File file0 = mockFile0.getCanonicalFile();
        File file1 = MockFile.createTempFile("X<VU", "GOJ");
        try {
            Files.equal(file0, file1);
            fail("Expecting exception: FileNotFoundException");

        } catch (FileNotFoundException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     newWriter() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test012() throws Throwable {
        File file0 = MockFile.createTempFile("/2", "w%.7]F}cT MVZWyx", (File) null);
        Charset charset0 = Charset.defaultCharset();
        Files.newReader(file0, charset0);
        FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
        Files.map(file0);
        // Undeclared exception!
        try {
            Files.newWriter((File) null, charset0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O único comportamento verificado pelo teste é se ele pode ser executado no tempo de 4s; Porém o teste é
    *     complexo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste e quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test013() throws Throwable {
        FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
        Files.createTempDir();
        File file0 = Files.createTempDir();
        Files.map(file0);
        Charset charset0 = mock(Charset.class, new ViolatedAssumptionAnswer());
        Files.fileTraverser();
        Files.getFileExtension("n9&+FMFJDrrPYo?T");
        Charset charset1 = mock(Charset.class, new ViolatedAssumptionAnswer());
        Charset charset2 = mock(Charset.class, new ViolatedAssumptionAnswer());
        file0.setWritable(false, false);
        Files.createTempDir();
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     equal() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test015() throws Throwable {
        String string0 = "T[[t]Jj!\\e`[c$YE?B";
        FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
        MockFile mockFile0 = new MockFile("T[[t]Jj!e`[c$YE?B");
        mockFile0.getParentFile();
        MockFile.createTempFile("T[[t]Jj!e`[c$YE?B", "T[[t]Jj!e`[c$YE?B", (File) mockFile0);
        // Undeclared exception!
        try {
            Files.equal(mockFile0, (File) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     createParentDirs() chamada com argumentos ilegais lança uma IOException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test016() throws Throwable {
        Files.getNameWithoutExtension("/~*/+sL7?$-`y");
        File file0 = Files.createTempDir();
        EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/private/var/folders/9c/2fm2fk412pj9zjkzvdx9w2fr0000gn");
        FileSystemHandling.appendLineToFile(evoSuiteFile0, "CharMatcher.breakingWhitespace()");
        try {
            Files.createParentDirs(file0);
            fail("Expecting exception: IOException");

        } catch (IOException e) {
            //
            // Unable to create parent directories of /var/folders/9c/2fm2fk412pj9zjkzvdx9w2fr0000gn/T/1392409281320-0
            //
            verifyException("com.google.common.io.Files", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test017() throws Throwable {
        Files.getFileExtension("/../com.google.common.io.CharSource$AsByteSource");
        MockFile mockFile0 = new MockFile("File");
        mockFile0.toPath();
        mockFile0.setExecutable(true);
        FileChannel.MapMode fileChannel_MapMode0 = FileChannel.MapMode.PRIVATE;
        Files.map((File) mockFile0, fileChannel_MapMode0);
        Files.map((File) mockFile0, fileChannel_MapMode0);
        Files.getFileExtension("/../AS");
        mockFile0.getCanonicalPath();
        Hasher hasher0 = mock(Hasher.class, new ViolatedAssumptionAnswer());
        doReturn((HashCode) null).when(hasher0).hash();
        HashFunction hashFunction0 = mock(HashFunction.class, new ViolatedAssumptionAnswer());
        doReturn(hasher0).when(hashFunction0).newHasher();
        mockFile0.mkdir();
        Files.hash(mockFile0, hashFunction0);
        Files.createParentDirs(mockFile0);
        Files.isDirectory();
        Files.getFileExtension("/../AS");
        Files.isDirectory();
        Files.move(mockFile0, mockFile0);
        mockFile0.mkdir();
        // Undeclared exception!
        try {
            Charset.forName("com.google.common.collect.DiscreteDomain$1");
            fail("Expecting exception: IllegalCharsetNameException");

        } catch (IllegalCharsetNameException e) {
            //
            // com.google.common.collect.DiscreteDomain$1
            //
            verifyException("java.nio.charset.Charset", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O único comportamento verificado pelo teste é se ele pode ser executado no tempo de 4s; Porém o teste é
    *     complexo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test018() throws Throwable {
        Files.getFileExtension("/../com.google.common.io.CharSource$AsByteSource");
        MockFile mockFile0 = new MockFile("CharSource$AsByteSource", "/../com.google.common.io.CharSource$AsByteSource");
        mockFile0.toPath();
        mockFile0.setExecutable(true);
        FileChannel.MapMode fileChannel_MapMode0 = FileChannel.MapMode.PRIVATE;
        Files.map((File) mockFile0, fileChannel_MapMode0);
        Files.map((File) mockFile0, fileChannel_MapMode0);
        Files.getFileExtension("/../AS");
        mockFile0.getCanonicalPath();
        Hasher hasher0 = mock(Hasher.class, new ViolatedAssumptionAnswer());
        doReturn((HashCode) null).when(hasher0).hash();
        HashFunction hashFunction0 = mock(HashFunction.class, new ViolatedAssumptionAnswer());
        doReturn(hasher0).when(hashFunction0).newHasher();
        mockFile0.mkdir();
        Files.hash(mockFile0, hashFunction0);
        Files.createParentDirs(mockFile0);
        Files.isDirectory();
        Files.getFileExtension("/../AS");
        Files.isDirectory();
        // Undeclared exception!
        try {
            Files.move(mockFile0, mockFile0);
            fail("Expecting exception: IllegalArgumentException");

        } catch (IllegalArgumentException e) {
            //
            // Source /Users/joaocorreia/guava/guava/CharSource$AsByteSource/../com.google.common.io.CharSource$AsByteSource and destination /Users/joaocorreia/guava/guava/CharSource$AsByteSource/../com.google.common.io.CharSource$AsByteSource must be different
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test020() throws Throwable {
        EvoSuiteFile evoSuiteFile0 = null;
        FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
        MockFile mockFile0 = new MockFile("com.google.common.base.Joiner");
        FileChannel.MapMode fileChannel_MapMode0 = FileChannel.MapMode.PRIVATE;
        Files.map((File) mockFile0, fileChannel_MapMode0, 998L);
        Files.equal(mockFile0, mockFile0);
        System.setCurrentTimeMillis((-912L));
        Files.toByteArray(mockFile0);
        File file0 = mockFile0.getCanonicalFile();
        Files.toByteArray(file0);
        // Undeclared exception!
        try {
            Charset.forName("com.google.common.base.Joiner");
            fail("Expecting exception: UnsupportedCharsetException");

        } catch (UnsupportedCharsetException e) {
            //
            // com.google.common.base.Joiner
            //
            verifyException("java.nio.charset.Charset", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test021() throws Throwable {
        String string0 = "+sL7";
        FileSystemHandling.shouldAllThrowIOExceptions();
        MockFile mockFile0 = new MockFile("+sL7");
        mockFile0.setReadable(true);
        mockFile0.toPath();
        Files.equal(mockFile0, mockFile0);
        Charset.defaultCharset();
        Charset.defaultCharset();
        // Undeclared exception!
        try {
            Charset.forName("+sL7");
            fail("Expecting exception: IllegalCharsetNameException");

        } catch (IllegalCharsetNameException e) {
            //
            // +sL7
            //
            verifyException("java.nio.charset.Charset", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste e quanto suas instruções são de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test024() throws Throwable {
        Files.getNameWithoutExtension("Files.isFile()");
        ByteProcessor<String> byteProcessor0 = (ByteProcessor<String>) mock(ByteProcessor.class, new ViolatedAssumptionAnswer());
        LinkedList<LinkedList<LinkedList<LinkedList>>> linkedList0 = new LinkedList<LinkedList<LinkedList<LinkedList>>>();
        FileChannel.MapMode fileChannel_MapMode0 = mock(FileChannel.MapMode.class, new ViolatedAssumptionAnswer());
        Files.getNameWithoutExtension("Files");
        OutputStream outputStream0 = mock(OutputStream.class, new ViolatedAssumptionAnswer());
        HashFunction hashFunction0 = mock(HashFunction.class, new ViolatedAssumptionAnswer());
        MockFile mockFile0 = new MockFile("Files", "$Lt%>9Rc#");
        try {
            Files.map((File) mockFile0);
            fail("Expecting exception: FileNotFoundException");

        } catch (FileNotFoundException e) {
            //
            // File does not exist, and RandomAccessFile is not open in write mode
            //
            verifyException("org.evosuite.runtime.mock.java.io.MockRandomAccessFile", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     move() chamada com argumentos ilegais lança uma FileNotFoundException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test025() throws Throwable {
        System.setCurrentTimeMillis(113L);
        FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "5Hr8l]acuu");
        MockFile mockFile0 = new MockFile("{fj", "{fj");
        File file0 = mockFile0.getParentFile();
        Files.asByteSource(file0);
        Files.getFileExtension("{fj");
        try {
            Files.move(file0, mockFile0);
            fail("Expecting exception: FileNotFoundException");

        } catch (FileNotFoundException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     map() chamada com argumentos ilegais lança uma FileNotFoundException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test027() throws Throwable {
        FileSystemHandling.shouldAllThrowIOExceptions();
        File file0 = Files.createTempDir();
        try {
            Files.map(file0);
            fail("Expecting exception: IOException");

        } catch (IOException e) {
            //
            // Simulated IOException
            //
            verifyException("org.evosuite.runtime.vfs.VirtualFileSystem", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     copy() chamada com argumentos ilegais lança uma FileNotFoundException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test030() throws Throwable {
        String string0 = "com.google.common.io.Closer$SuppressingSuppressor";
        Files.getFileExtension("com.google.common.io.Closer$SuppressingSuppressor");
        MockFile mockFile0 = new MockFile("com.google.common.io.Closer$SuppressingSuppressor");
        try {
            Files.copy((File) mockFile0, (File) mockFile0);
            fail("Expecting exception: FileNotFoundException");

        } catch (FileNotFoundException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
        }
    }

}
